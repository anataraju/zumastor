<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
	<TITLE>Zumastor design and implementation notes</TITLE>
	<META NAME="AUTHOR" CONTENT="Frank Mayhar">
	<META NAME="CREATED" CONTENT="20070913;13250800">
	<STYLE TYPE="text/css">
	<!--
		BODY { font-family: "Verdana", sans-serif; }
		H1 { font-size: 16pt; margin-top: 0.17in; margin-bottom: 0.1in; text-align: center }
		P { margin-bottom: 0.1in }
		H3 { font-size: 13pt; margin-top: 0.1in; margin-bottom: 0.1in; text-align: left }
		H2 { font-size: 14pt; margin-top: 0.2in; margin-bottom: 0.1in; text-align: left }
		H4 { margin-top: 0.05in; margin-bottom: 0.1in; text-align: left }
	-->
	</STYLE>
</HEAD>
<BODY>
<H1>Zumastor design and implementation notes</H1>
<H3>Snapshots versus the origin.</H3>
<P>When a snapshot is taken, it is empty; all reads
and writes get passed through to the origin. When an origin write
happens, the affected chunk or chunks must be copied to any extant
snapshots. (This chunk is referred to as an &quot;exception&quot; to
the rule that all chunks belong to the origin.) The make_unique()
function checks whether the chunk needs to be copied out, does so if
necessary, and returns an indication of whether that happened.</P>
<H3>Path of a bio request through dm-ddsnap and ddsnapd.</H3>
<H4>The path a bio request takes as a result of a read from a snapshot device
that goes to the origin.</H4>
<UL>
	<LI><B>Kernel (dm-ddsnap):</B>
	<UL>
		<LI>Generic device handling (or in this case the device mapper) calls
		ddsnap_map() with the initial bio. ddsnap_map() queues the bio on
		the &quot;queries" queue of the dm_target private (devinfo)
		structure.</li>
		<li>worker() finds the bio on the "queries" queue. It
		dequeues it from "queries" and queues it on the "pending"
		queue, then sends a QUERY_SNAPSHOT_READ message to ddsnapd.</li>
	</UL></li>
	<li><B>Process space (ddsnapd):</B>
	<UL>
		<li>incoming() gets QUERY_SNAPSHOT_READ, vets it, performs
		readlock_chunk() (to assert a snaplock) for each chunk shared with
		origin, sends SNAPSHOT_READ_ORIGIN_OK message to kernel.</li>
	</UL></li>
	<li><B>Kernel (dm-ddsnap):</B>
	<UL>
		<li>incoming() gets SNAPSHOT_READ_ORIGIN_OK, calls replied_rw().</li>
		<li>replied_rw() finds each chunk id in "pending" queue,
		dequeues it. For a read from the origin (per
		SNAPSHOT_READ_ORIGIN_OK), sets the bi_end_io callback to
		snapshot_read_end_io() and queues the bio in the "locked"
		queue. It then passes the request to lower layers via
		generic_make_request().</li>
		<li>When the request has completed, the lower level calls
		snapshot_read_end_io(), which moves the bio from the "locked"
		queue to the "releases" queue (and pings the worker that
		there's more work). It also calls any chained end_io routine.</li><li>
		worker() finds the bio on the "releases" queue. It
		dequeues it from "releases" and sends a
		FINISH_SNAPSHOT_READ message to ddsnapd.</li>
	</ul></li>
	<li><B>Process space (ddsnapd):</B> 
	<UL>
		<li>incoming() gets FINISH_SNAPSHOT_READ and calls release_chunk() for
		each chunk, which in turn calls release_lock() which releases and
		destroys all requests on the "pending" queue as well as
		the lock itself.</li>
	</UL></li>
</UL>
<H4>The path a bio request takes as a result of a write to the origin device.</H4>
<UL>
	<li><B>Kernel (dm-ddsnap):</B>
	<UL>
		<li>Generic device handling (or in this case the device mapper)
		calls ddsnap_map() with the initial bio. ddsnap_map() queues
		the bio on the "queries"
		queue of the dm_target private (devinfo) structure.</li>
		<li>worker() finds
		the bio on the "queries" queue. It dequeues it from
		"queries" and queues it on the "pending" queue,
		then sends a QUERY_WRITE message to ddsnapd.</li>
	</UL></li>
	<li><B>Process space (ddsnapd):</B>
	<UL>
		<li>incoming() gets QUERY_WRITE for the origin (snaptag of -1).</li>
		<li>Calls make_unique() to copy each chunk out to snapshot(s) if
		necessary.</li>
		<li>If chunk was copied out, calls waitfor_chunk(), which finds any
		snaplock outstanding for the chunk. If one is found, it adds the
		request to the lock "pending" queue.</li>
		<li>If no chunk was queued "pending," it sends an
		ORIGIN_WRITE_OK message to the kernel. Otherwise it copies that
		message to the message buffer at the head of the "pending"
		queue and finishes.</li>
	</UL></li>
	<li><B>Kernel (dm-ddsnap):</B>
	<UL>
		<li>incoming() gets ORIGIN_WRITE_OK, calls replied_rw().</li>
		<li>replied_rw() finds each chunk id in "pending" queue,
		dequeues it. For a write to the origin (per ORIGIN_WRITE_OK), it
		passes the request to lower layers via generic_make_request().</li>
	</UL></li>
</UL>
<H4>The path a bio request takes as a result of a
write to a snapshot device.</H4>
<UL>
	<li><B>Kernel (dm-ddsnap):</B>
	<UL>
		<li>Generic device
		handling (or in this case the device mapper) calls ddsnap_map()
		with the initial bio. ddsnap_map() queues the bio on the "queries"
		queue of the dm_target private (devinfo) structure.</li>
		<li>worker() finds
		the bio on the "queries" queue. It dequeues it from
		"queries" and queues it on the "pending" queue,
		then sends a QUERY_WRITE message to ddsnapd.</li>
	</UL></li>
	<li><B>Process space (ddsnapd):</B>
	<UL>
		<li>incoming() gets QUERY_WRITE for a snapshot.</li>
		<li>If snapshot not squashed, calls make_unique() to copy each chunk
		from the origin out to snapshot(s) if necessary.</li>
		<li>Sends a SNAPSHOT_WRITE_OK (SNAPSHOT_WRITE_ERROR if squashed or an
		error on make_unique()) message to the kernel.</li>
	</UL></li>
	<li><B>Kernel (dm-ddsnap):</B>
	<UL>
		<li>incoming() gets SNAPSHOT_WRITE_OK, calls replied_rw().</li>
		<li>replied_rw() finds each chunk id in "pending" queue,
		dequeues it. For a write to a snapshot (per SNAPSHOT_WRITE_OK), it
		fills in the appropriate device and computes the physical block for
		each chunk, then passes the request to lower layers via
		generic_make_request().</li>
	</UL></li>
</UL>
<H2>Startup stuff (in progress).</H2>
<UL>
	<li>Generally, the agent gets a new connection, accepts it, allocates
	a client structure and adds to its client list.  It adds the fd for
	that client to the poll vector and uses the offset therein to locate
	the client information later.</li>
	<li>dm-ddsnap clnt starts and initializes, sends NEED_SERVER to agent,
	blocks on server_in_sem.</li>
	<ul>
		<li>Agent gets NEED_SERVER, calls have_address() (which unconditionally
		returns true), then calls connect_clients():
		<ul>
			<li>Connects to client address.</li>
			<li>Sends CONNECT_SERVER and fd to dm-ddsnap cntl.</li>
		</ul>
		</li>
	</ul>
	<li>ddsnapd starts and initializes, then sends SERVER_READY to agent.</li>
	<ul>
		<li>Agent gets SERVER_READY, calls try_to_instantiate() to send
		START_SERVER to ddsnapd (which initializes its superblock).</li>
		<li>Agent calls connect_clients():
		<ul>
			<li>Connects to client address.</li>
			<li>Sends CONNECT_SERVER and fd to dm-ddsnap cntl.</li>
		</ul>
		</li>
	</ul>
	<li>dm-ddsnap cntl gets CONNECT_SERVER, gets fd, ups server_in_sem
	(unblocking clnt), sends IDENTIFY over just-received server fd, ups
	recover_sem.</li>
	<li>ddsnapd gets IDENTIFY, sends IDENTIFY_OK to clnt, passing
	"chunksize_bits." <i>(To "identify" a snapshot?  What does this
	mean?)</i></li>
	<li>dm-ddsnap clnt gets IDENTIFY_OK:</li>	
	<UL>
		<li>Sets READY_FLAG.</li>
		<li>Sets chunksize_bits from message.</li>
		<li>Sends CONNECT_SERVER_OK to agent.</li>
		<li>ups identify_sem, which allows ddsnap_create() to return.</li>
	</UL>
	</li>
	<li>Agent receives CONNECT_SERVER_OK, does nothing.</li>
</UL>
<H2>Glossary</H2>
<UL>
	<li><B>exception</B>:
	A chunk that no longer exists solely on the origin, but has been
	modified after a snapshot was taken, so that a copy of the old
	contents has been made in the affected snapshot(s).</li>
</UL>
</BODY>
</HTML>
